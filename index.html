<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/23/hello-world/" class="article-date">
  <time datetime="2018-07-23T03:03:37.343Z" itemprop="datePublished">2018-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/23/hello-world/">my onion</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/23/hello-world/" data-id="cjjxqbpr90005c4uj7zc0r05x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习中的数学基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/03/机器学习中的数学基础/" class="article-date">
  <time datetime="2018-03-03T09:57:47.000Z" itemprop="datePublished">2018-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/03/机器学习中的数学基础/">负梯度方向-函数值下降最快的方向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>将$ f(x_k+\delta)$泰勒级数展开：<br>$$<br>  \begin{matrix}<br>   f(x_k+\delta)\approx f(x_k）+f^1(x_k) \cdot\delta+1/2f^2(x_k) \cdot\delta^2+…+(1/n!) \cdot f^n(x_k) \cdot\delta^n\<br>  \end{matrix} \tag{1}<br>$$<br>因为式（1）中后几项的值相比前几项来说比较小，比如看前三项，将前三项写为矢量形式：</p>
<p>$$<br>  \begin{matrix}<br>   f(x_k+\delta)\approx f(x_k）+ \nabla^Tf(x_k) \cdot\delta+1/2\cdot\delta^T\nabla^2f(x_k) \cdot\delta\<br>  \end{matrix} \tag{2}<br>$$<br>看式（2）的前两项，可得：</p>
<p>当 $\delta = \nabla^Tf(x_k)$，也就是对于向量来说，两者方向相同时，$\nabla^Tf(x_k) \cdot\delta$取得最大值。</p>
<p>所以，$\delta$ 选择梯度方向，函数值最快上升；$\delta$ 选择负梯度方向，函数值最快下降。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/03/机器学习中的数学基础/" data-id="cjjxqbprc0008c4uj8bh9brhs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ML数学基础/">ML数学基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基本排序方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/基本排序方法/" class="article-date">
  <time datetime="2018-02-27T06:22:58.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/基本排序方法/">基本排序方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h1><hr>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 堆排序</li>
<li style="list-style: none"><input type="checkbox" checked> 希尔排序</li>
<li style="list-style: none"><input type="checkbox" checked> 快速排序</li>
<li style="list-style: none"><input type="checkbox" checked> 插入排序</li>
<li style="list-style: none"><input type="checkbox" checked> 直接选择排序</li>
<li style="list-style: none"><input type="checkbox" checked> 冒泡排序</li>
</ul>
<p>总结如下：</p>
<p><img src="http://img.blog.csdn.net/20130801171021937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam51X3NpbWJh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="示意图 "></p>
<p>本篇博客所有排序为从小到大;python3。（尚未完成所有的排序。。。。）</p>
<h1 id="一、冒泡排序-BubbleSort"><a href="#一、冒泡排序-BubbleSort" class="headerlink" title="一、冒泡排序 BubbleSort"></a>一、冒泡排序 BubbleSort</h1><p>介绍：</p>
<p>冒泡排序，如果您想把大的放到最后，所以从第一位开始比较（每次都与下一位比它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。）</p>
<p>步骤：</p>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>源代码：(python实现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 最差版</span><br><span class="line">def BubbleSort1(array):</span><br><span class="line">    length = len(array)</span><br><span class="line">    if length == 0 :</span><br><span class="line">        return False</span><br><span class="line">    else :</span><br><span class="line">        for i in range(length):#总共需要遍历length次,第一次排完后，最大的被排到了末位</span><br><span class="line">            for j in range (1,length-i):</span><br><span class="line">                if array[j-1] &gt; array[j]:</span><br><span class="line">                    array[j-1],array[j] = array[j],array[j-1]</span><br><span class="line">        return array</span><br></pre></td></tr></table></figure></p>
<p>不过针对上述代码还有两种优化方案。</p>
<p>优化1：最差版，排序次数最多，如果中途就已经排好顺序，则没有必要在进行排序。</p>
<p> #即（某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了，用一个标记记录这个状态即可。）<br>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。 因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<p>优化版1、2详见这里</p>
<h1 id="二、选择排序-SelectionSort"><a href="#二、选择排序-SelectionSort" class="headerlink" title="二、选择排序 SelectionSort"></a>二、选择排序 SelectionSort</h1><p>介绍：</p>
<p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>
<p>步骤：</p>
<p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>以此类推，直到所有元素均排序完毕。<br>源代码：(python实现)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 选择排序 SelectionSort</span><br><span class="line"># 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</span><br><span class="line"># 再从剩余未排序元素中继续寻找最小（大）元素，然后放到 &quot;已排序序列&quot;的末尾。</span><br><span class="line"># 以此类推，直到所有元素均排序完毕</span><br><span class="line">#核心，开始时，锁定最小元素应该存放的位置：第0位。然后从余下元素中找出最小值，替换第0位</span><br><span class="line">#比如a=[2,5,1,3],a[0]=2,从[5,1,3]中找出最小的是第二位元素a[2]=1,交换a的第0元素与第2元素（而不是每次都与a[0]比较，得：【1，5，2，3】</span><br><span class="line">#=从小到大排列=============================================================================</span><br><span class="line">def SelectionSort(array):</span><br><span class="line">    length = len(array)</span><br><span class="line">    if length == 0 :</span><br><span class="line">        return False</span><br><span class="line">    else :</span><br><span class="line">        for i in range(0,length):</span><br><span class="line">            mini =i#此次遍历的min值在数组中的位置</span><br><span class="line">            for j in range(i+1,length):                                             </span><br><span class="line">                if array[j] &gt; array[mini]: </span><br><span class="line">                    mini=j #此次比较产生了更小的值，记录它的下标</span><br><span class="line">                array[j],array[mini] = array[mini],array[j]        </span><br><span class="line">        return array</span><br></pre></td></tr></table></figure></p>
<h1 id="三、插入排序-InsertionSort"><a href="#三、插入排序-InsertionSort" class="headerlink" title="三、插入排序 InsertionSort"></a>三、插入排序 InsertionSort</h1><p>1.从第一个元素开始，该元素可以认为已经被排序<br>2.取出下一个元素，在已经排序的元素序列中从后向前扫描<br>3.如果被扫描的元素（已排序）大于新元素，将该元素后移一位<br>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>5.将新元素插入到该位置后<br>重复步骤2~5。</p>
<p>操作过程示意图：</p>
<p><img src="http://wuchong.me/img/Insertion-sort-example-300px.gif" alt="示意图 "></p>
<pre><code>#插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

def InsertionSort(array):
    length = len(array)
    if length == 0 :
        return False    
    else :    
        for i in range(1,length):#每个未排序数据
            if array[i]&lt;array[i-1]:    
                mini=array[i]#给array[i]找到合适的插入位置
                index=i
                for j in range (i-1,-1,-1):#和已排序序列比较
                    if array[j] &gt; mini:
                        array[j+1] = array[j]
                        index = j      #目前最合适的插入位置               
                    else :
                        break
                array[index]=mini#和已排序序列比较完了，将array[i]插入合适位置
        return array
</code></pre><h1 id="四、希尔排序-ShellSort"><a href="#四、希尔排序-ShellSort" class="headerlink" title="四、希尔排序 ShellSort"></a>四、希尔排序 ShellSort</h1><p>【1】介绍：</p>
<p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是<code>非稳定排序算法</code>。</p>
<p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p>
<p>【2】例如</p>
<p>假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<pre><code>13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
</code></pre><p>然后我们对每列进行排序：</p>
<pre><code>10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
</code></pre><p>将上述四行数字，依序接在一起时我们得到：<code>[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]</code>。这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<pre><code>10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
</code></pre><p>排序之后变为：</p>
<pre><code>10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
</code></pre><p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<pre><code>

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/27/基本排序方法/" data-id="cjjxqbpre000dc4ujskfe4xg5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CNN推导" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/25/CNN推导/" class="article-date">
  <time datetime="2018-02-25T03:04:14.000Z" itemprop="datePublished">2018-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/25/CNN推导/">CNN推导+反向传播</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="卷积神经网络过程详解–wangafufu"><a href="#卷积神经网络过程详解–wangafufu" class="headerlink" title="卷积神经网络过程详解–wangafufu"></a>卷积神经网络过程详解–wangafufu</h1><p> DeepLearning</p>
<h1 id="总共分四部分介绍："><a href="#总共分四部分介绍：" class="headerlink" title="总共分四部分介绍："></a>总共分四部分介绍：</h1><p>本文主要目的，整体把握卷积神经网络的细节。<br>感觉网上介绍细节的很多，不知道整体，脾气不好的小孩，容易不开心惹，比如我。。吼吼</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 1. 特点：局部连接，权值共享。</li>
<li style="list-style: none"><input type="checkbox" checked> 2. 前向传播计算：理解多通道卷积（卷积输入的长度、宽度、深度）卷积计算和池化。</li>
<li style="list-style: none"><input type="checkbox" checked> 3. 误差项的反向传播：将损失函数先对输出层的输入值求导，得出最后一层的误差项，再利用梯度公式，寻找规律，根据最后一层的误差项反推出每一层的误差项，最后得到所有层的误差项。</li>
<li style="list-style: none"><input type="checkbox" checked> 4. 权重更新：利用每层的误差项对权重w和偏置b进行更新——损失函数对每层的filter(w1,w2,,b)求导，来更新参数。</li>
</ul>
<h1 id="具体如下："><a href="#具体如下：" class="headerlink" title="具体如下："></a>具体如下：</h1><h1 id="1-特点：局部连接，权值共享。"><a href="#1-特点：局部连接，权值共享。" class="headerlink" title="1. 特点：局部连接，权值共享。"></a>1. 特点：局部连接，权值共享。</h1><p>见下图。第一个框图为全连接，每个s均与所有的x相连接，每个w值各异；第二个框图为添加’局部连接‘的示意图，每个s均与3个x相连接，减少了参数个数，例如s2拥有自己的一组权重 W2 =（w21,w22,w23，w24）,W1 W2 W3 各异；在第二个框图基础上再添加’权值共享‘，则，得到W1=W2=W3，进一步减少了参数个数。</p>
<p><img src="http://manutdzou.github.io/public/img/posts/CNN%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%AF%A6%E8%A7%A3/2.png" alt="我的头像"></p>
<h1 id="2-前向传播–卷积运算"><a href="#2-前向传播–卷积运算" class="headerlink" title="2. 前向传播–卷积运算"></a>2. 前向传播–卷积运算</h1><p>学会计算参数个数，就明白卷积是怎么卷的了，参考我的 <a href="https://www.zybuluo.com/mdeditor#1015070" target="_blank" rel="noopener">多通道卷积</a> </p>
<ul>
<li><p>前向传播<br>深度为n=1，1 filter，所以卷积结果为1个feature map<br>[L层——k个filter(每个filter可以有m个卷积模板，即每个fliter的深度为m)——L+1层（k个featuer map ）]<br><img src="http://upload-images.jianshu.io/upload_images/2256672-273e3d9cf9dececb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="我的头像"><br>深度为n=4。2 filter，所以卷积结果为2个featuer map。</p>
<p><img src="http://dataunion.org/wp-content/uploads/2015/03/91.png" alt="我的头像"></p>
</li>
</ul>
<h1 id="3-误差反向传播"><a href="#3-误差反向传播" class="headerlink" title="3.  误差反向传播"></a>3.  误差反向传播</h1><p><strong>核心思想</strong>：<br>参照下图1(L、 L-1 层间的前向传播)，一步一步耐心的进行梯度的链式求导。<br>每层的误差项：对输入值求导——损失函数对该层中每个神经元的输入值分别求导，即得到每个神经元对应的误差项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A[本层输入值a \ 激活函数f, L-1层  * ] --&gt;|*卷积*| B(卷积结果\激活函数f,L层  *) </span><br><span class="line">B --&gt; C(OUT)</span><br><span class="line">C --&gt; | *误差计算 *| D[损失函数]</span><br></pre></td></tr></table></figure>
<pre><code>图1
</code></pre><p><strong> 总述： </strong></p>
<p>对于每一层，将损失函数对每一个神经元的输入值a求导，即得到每一个神经元输入值的误差。下图为L、 L-1 层的误差项，中间的filter为原filter旋转180度之后的结果。并且下图为卷积时步长为1，深度为1，滤波器个数为1时对应的误差项情况；步长，深度，滤波器个数增多时，误差项可以经过不太复杂的推广得到。<br>前向传播时：<strong><em>L-1层（D个feature map）——&gt; N个卷积核——&gt; L层（N个feature map）</em></strong><br>误差由L层向 L-1 层传递，传递方式:<br><strong>误差（L-1）= 反转后的filter*误差（L）</strong><br><strong><em>L-1层（D个sensitivity map）&lt;—— N个卷积核&lt;—— L层（N个sensitivity map）</em></strong><br>以此类推，计算出各层中每个神经元的误差项。<br>  <img src="http://upload-images.jianshu.io/upload_images/2256672-2fb37b0a3ff0e1f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="我的头像"></p>
<p><strong>*引申</strong>：<br>当步长改变，深度增多，滤波器filter个数增多，L-1层的 feature map 个数增多时，要进行误差传递，就相应参考以上进行filter反转的卷积操作和多通道卷积过程;思考误差反向传播的过程时，注意每层的误差项个数与参数个数的对应相等。</p>
<p><strong>引申1.</strong> 卷积步长为S时的误差传递<br>我们先来看看步长为S与步长为1的差别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2256672-754f37eb7603e99f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="我的头像"></p>
<p>如上图，上面是步长为1时的卷积结果，下面是步长为2时的卷积结果。我们可以看出，因为步长为2，得到的feature map跳过了步长为1时相应的部分。因此，当我们反向计算误差项时，我们可以对步长为S的sensitivity map相应的位置进行补0，将其『还原』成步长为1时的sensitivity map，再进行滤波器反转卷积求误差。</p>
<p><strong>引申2</strong>.  L-1层深度为D，L层有1个卷积核时的误差传递</p>
<p>（1）当L-1层深度为D时（L-1层有D个feature map），filter的深度也必须为D（1个卷积核，这个卷积核对应D个卷积模板），L-1层的D个feature map分别只与对应的卷积模板进行卷积计算：<br><strong><em>L-1层（D个feature map）——&gt; 1个卷积核——&gt; L层（1个feature map）</em></strong><br>因此，<br>（2）反向计算误差项时，我们可以用这个卷积核对应D个卷积模板分别与L层的这一个sensitivity map进行卷积，得到L-1层的D个sensitivity map。如下图所示：<br><strong><em>L-1层（D个sensitivity map）&lt;—— 1个卷积核(D个卷积模板) &lt;—— L层（1个sensitivity map）</em></strong><br><img src="http://upload-images.jianshu.io/upload_images/2256672-af2da9701a03dc3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="我的头像"></p>
<p><strong>引申3</strong>.  filter数量为N时的误差传递（区分filter的数量和深度）<br>     (1)  filter数量为N时，输出层的深度也为N，第n个filter卷积产生输出层的第n个feature map。<br><strong><em>L-1层（D个feature map）——&gt; N个卷积核filter(每个卷积核有D个卷积模板)——&gt; L层（N个feature map，，每个filter对应一个feature map）</em></strong><br>因此，<br>（2）反向计算误差项时，<br><strong><em>L-1层（D个sensitivity map）&lt;—— N个卷积核filter(每个卷积核有D个卷积模板) &lt;—— L层（N个sensitivity map）</em></strong><br>由于第L-1层每个加权输入都同时影响了第L层所有feature map的输出值，因此，反向计算误差项时，需要使用全导数公式。也就是，我们先使用第m个filter（D个卷积模板）与对应的第L层的第m个sensitivity map进行卷积，得到D个偏sensitivity map，称这D个偏sensitivity map为一组。依次用每个filter做这种卷积，就得到N组偏sensitivity map。最后在各组之间将N个偏sensitivity map 按对应filter、对应元素相加，即得到D个sensitivity map，就是最终的L-1层的那D个sensitivity map。</p>
<p><strong>引申4.</strong>  <strong>池化层的误差传播</strong></p>
<p>最大池化：最大元素对应位置误差原路返回，其余位置的为误差项为零，然后反向传回<br>均值池化：均分误差，然后反向传回</p>
<h1 id="4-权重更新"><a href="#4-权重更新" class="headerlink" title="4. 权重更新"></a>4. 权重更新</h1><p> 损失函数对每层的filter中的每个w(w1,w2,,)求导，来更新参数：需要用到反向传播求出的误差项。梯度公式推导后，可以看出，求L层的w相对损失函数的梯度，实际是利用反向传播得到的L层的误差项结果、L-1层的输出值进行计算。</p>
<h1 id="5-题外话"><a href="#5-题外话" class="headerlink" title="5. 题外话"></a>5. 题外话</h1><p>题外话1：公式推导并不难，大家不要被吓到，只要牢记  图1 的结构，耐心利用链式求导法则，稍微调用一下高数知识即可~<br>题外话2：本菜菜在详细学习时，发现，公式推导不难，难的时整体把握。比如理解卷积的深度（多通道卷积）、反向传播时误差项与前向传播时权重的互相对应（毕竟，求误差项是给各个权重参数求的），利用求得的误差项进行参数更新。详细公式我在草纸上推导了，搬移公式实在太麻烦了，就不拷贝啦~<br>题外话3：通过本菜菜几天的研究，建议先整体把握，再去啃公式，不然容易看完不知道干什么的。</p>
<h2 id="详细公式可以参考并非常感谢：此博客"><a href="#详细公式可以参考并非常感谢：此博客" class="headerlink" title="详细公式可以参考并非常感谢：此博客"></a>详细公式可以参考并非常感谢：<a href="https://www.zybuluo.com/hanbingtao/note/485480" target="_blank" rel="noopener">此博客</a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/25/CNN推导/" data-id="cjjxqbpr80003c4ujixmkeq5z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DeepLearning/">DeepLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Hexo+Github" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/24/Hexo+Github/" class="article-date">
  <time datetime="2018-02-24T09:29:17.000Z" itemprop="datePublished">2018-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/24/Hexo+Github/">Hexo+Github+next+mathJax</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>想要畅通无阻的美滋滋的上传博客，包括文字内容和公式，完完整整总共十大步流程，亲自折腾过的总结：</p>
<ol>
<li>搭建Node.js</li>
<li>搭建Git 环境</li>
<li>GitHub 注册和配置</li>
<li>安装配置 Hexo</li>
<li>关联 Hexo 与 GitHub Pages</li>
<li>发表文章 </li>
<li>更换主题theme</li>
<li>多PC同步管理博客（可略过）</li>
<li>如何向Github提交代码</li>
<li>添加mathJax</li>
</ol>
<h1 id="1-搭建Node-js"><a href="#1-搭建Node-js" class="headerlink" title="1. 搭建Node.js"></a>1. 搭建Node.js</h1><ul>
<li>在 Node.js 官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载安装包 ,一路next即可.</li>
<li>然后打开命令提示符，输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v、npm -v，</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>出现版本号则说明 Node.js 环境配置成功！！！</p>
<h1 id="2-搭建Git-环境"><a href="#2-搭建Git-环境" class="headerlink" title="2. 搭建Git 环境"></a>2. 搭建Git 环境</h1><p> 因为需要把本地的网页和文章等提交到 GitHub 上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<ul>
<li>在 Git 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载安装包 ，安装。</li>
<li><p>桌面右键，打开 Git Bush Here，输入 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>出现版本号则说明 Git 环境配置成功，第二步完成！！！</p>
</li>
</ul>
<h1 id="3-GitHub-注册和配置"><a href="#3-GitHub-注册和配置" class="headerlink" title="3.GitHub 注册和配置"></a>3.GitHub 注册和配置</h1><ul>
<li>创建仓库：Repository name 使用自己的用户名，仓库名规则：<br>注意：yourname 必须是你的用户名： yourname/yourname.github.io</li>
<li>访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。</li>
</ul>
<h1 id="4-安装配置-Hexo"><a href="#4-安装配置-Hexo" class="headerlink" title="4.安装配置 Hexo"></a>4.安装配置 Hexo</h1><ul>
<li>我是在D盘新建了一个hexo文件夹，在这个路径D\hexo下cmd,安装一下内容的</li>
<li><p>使用 npm 安装 Hexo：在命令行中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>等待安装，有warn无所谓的啦</p>
</li>
<li><p>继续输入  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<p>出现版本信息，则安装OK</p>
</li>
<li><p>安装 Hexo 完成后，请执行下列命令来初始化 Hexo，用户名改成你的，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init onionwyc.github.io</span><br><span class="line">cd onionwyc.github.io</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行本地 Hexo 服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">或者</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>无法打开 localhost4000<br>不怕，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -server --save</span><br><span class="line">hexo s -p 3600</span><br></pre></td></tr></table></figure></p>
<ul>
<li>打开<a href="http://localhost:3600/" target="_blank" rel="noopener">http://localhost:3600/</a><br>成功出现 Hexo 界面！！激动啊</li>
</ul>
<h1 id="5-关联-Hexo-与-GitHub-Pages"><a href="#5-关联-Hexo-与-GitHub-Pages" class="headerlink" title="5.关联 Hexo 与 GitHub Pages"></a>5.关联 Hexo 与 GitHub Pages</h1><p>我们利用 SSH keys让本地git项目与远程的github联系起来！<br>右键选择 Git Bash Here, 中操作:</p>
<p> 生成SSH keys<br> 输入你自己的邮箱地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;onionwuyc@gmail.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>  在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空  的话提交项目时则不用输入，我们按回车不设置密码。</p>
<p>  添加 SSH Key 到 GitHub<br>  打开 C:\Users\.ssh\id_rsa.pub，此文件里面内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 <a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a> 的 new SSH key 中</p>
<p>  测试<br>  可以输入下面的命令，看看设置是否成功，<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>的部分不要修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>如果提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi defnngj You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>说明你连接成功了</p>
<p>如果是下面的反馈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>  不要紧张，输入yes就好，然后会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi aierui! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>配置Git个人信息</p>
<p>  现在你已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。<br>Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;onionwyc&quot;</span><br><span class="line">git config --global user.email &quot;onionwuyc@gmail.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>配置 Deployment</p>
<p>在_config.yml文件中，找到Deployment，然后按照如下修改，用户名改成你的：<br>需要注意的是：冒号后面记得空一格！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:onionwyc/onionwyc.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<h1 id="6-发表文章"><a href="#6-发表文章" class="headerlink" title="6.发表文章"></a>6.发表文章</h1><ul>
<li>进入你的博客目录，右键选择 Git Bash Here 进入命令窗口，输入下面代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新建文章名称&quot;    #新建文章</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进入你的博客目录，在 /source/_posts 文件夹下直接建立一个.md文件。</span><br></pre></td></tr></table></figure></p>
<p> 此时，在方法1所述的文件夹里便有了 新建文章名称.md 文件。</p>
<ul>
<li>发布新建文章<br>在该博客项目文件夹下运行 Git Bash Here 命令窗口，依次输入如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo generate    #生成更改</span><br><span class="line">hexo deploy    #将生成的更改部署到码云或者GitHub上</span><br><span class="line">或者</span><br><span class="line">先hexo g再执行hexo d布署</span><br><span class="line">或者</span><br><span class="line">也可使直接用hexo d -g</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>错误处理：<br>在执行 hexo deploy 后,出现 error deployer not found:git 的错误处理<br>输入代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>再次传送：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
<p>可以直接进入onionwyc.github.io或者去自己的github中查看，发表成功！开心~<br>==注意==</p>
<ul>
<li>部署到GitHub时，可能因为网速、被墙等原因，需要多次运行 hexo deploy  ；有时候可以运行 hexo clean 后在运行上述代码。</li>
<li>.md文件不要用记事本打开，建议使用具有markdown语法的程序打开，比如：s ubline text、notepad++等。也可以使用在线markdown编辑器。</li>
<li>文章已经发表，又重新更改了，先执行 hexo clean,再 hexo d -g即可</li>
</ul>
<h1 id="7-更换主题theme"><a href="#7-更换主题theme" class="headerlink" title="7.更换主题theme"></a>7.更换主题theme</h1><ul>
<li>官网下载新的人见人爱的next主题，官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li>
<li>Hexo主题推荐使用 Next 为主题，请阅读 Next 的官方文档（ <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a> ），5 分钟快速安装。</li>
<li>将下载的压缩包解压至D:\hexo\onionwyc.github.io\themes下，并重名命为next</li>
<li>将 D:\hexo\onionwyc.github.io 下的站点配置文件_config中的theme项修改为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme :next</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></p>
<p>进行本地测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 3600</span><br></pre></td></tr></table></figure></p>
<p>然后就可以在<a href="http://localhost:3600/.中看到新主题" target="_blank" rel="noopener">http://localhost:3600/.中看到新主题</a><br>添加插件<br>添加 sitemap 和 feed 插件</p>
<p>切换到你本地的 hexo 目录 ，在命令行窗口，输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed -save</span><br><span class="line">npm install hexo-generator-sitemap -save</span><br></pre></td></tr></table></figure></p>
<p>修改hexo/onionwyc.github.io/ _config.yml，增加以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">Plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">#sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure></p>
<p>再执行以下命令，部署服务端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure></p>
<p>配完之后，就可以访问 <a href="https://onionwyc.github.io/atom.xml" target="_blank" rel="noopener">https://onionwyc.github.io/atom.xml</a> 和 <a href="https://onionwyc.github.io/sitemap.xml" target="_blank" rel="noopener">https://onionwyc.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。<br>访问<a href="https://onionwyc.github.io" target="_blank" rel="noopener">https://onionwyc.github.io</a> 可以看到主题已经更改。<br>每次更改主题配置中的内容后，执行下列命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  #清除缓存</span><br><span class="line">hexo d -g   #部署到服务端</span><br></pre></td></tr></table></figure></p>
<h1 id="8-多PC同步管理博客"><a href="#8-多PC同步管理博客" class="headerlink" title="8.多PC同步管理博客"></a>8.多PC同步管理博客</h1><p>很多人可能家里一台笔记本，公司一个台式机，想两个同时管理博客，同时达到备份的博客主题、文章、配置的目的。下面就介绍一下用github来备份博客并同步博客。</p>
<ul>
<li><p>A电脑备份博客内容到github<br>配置.gitignore文件。进入博客目录文件夹下，找到此文件，用sublime text     打开，在最后增加两行内容/.deploy_git和/public</p>
<p>初始化仓库。<br>在博客根目录下，在git bash下依次执行git init和git remote add origin 为远程仓库地址。</p>
<p>同步到远程仓库。<br>gitbash下依次执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add . #添加目录下所有文件</span><br><span class="line">git commit -m &quot;更新说明&quot; #提交并添加更新说明</span><br><span class="line">git push -u origin master #推送更新到远程仓库</span><br></pre></td></tr></table></figure>
</li>
<li><p>B电脑拉下远程仓库文件<br>在B电脑上同样先安装好node、git、ssh、hexo，然后建好hexo文件夹，安装好插件，（然后选做：将备份到远程仓库的文件及文件夹删除），然后执行以下命令：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin &lt;server&gt;</span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>
<p>发布博客后同步<br>在B电脑发布完博客之后，记得将博客备份同步到远程仓库<br>执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">#可以用git master 查看更改内容</span><br><span class="line">git commit -m &quot;更新信息&quot;</span><br><span class="line">git push -u origin master  #以后每次提交可以直接git push</span><br></pre></td></tr></table></figure>
<p>平时同步管理<br>每次想写博客时，先执行：git pull进行同步更新。发布完文章后同样按照上面的 发布博客后同步 同步到远程仓库。</p>
<ul>
<li>中文乱码<br>在 md 文件中写中文内容，发布出来后为乱码，原因是 md 的编码不对，将 md 文件另存为UTF-8编码的文件即可解决问题。</li>
</ul>
<p>主要参考并感谢 <a href="http://www.lovebxm.com/2017/05/30/buildBlog/#%E5%A4%9APC%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A" target="_blank" rel="noopener">此作者</a> </p>
<h1 id="9-如何向Github提交代码"><a href="#9-如何向Github提交代码" class="headerlink" title="9. 如何向Github提交代码"></a>9. 如何向Github提交代码</h1><ul>
<li><p>在Github新建一个仓库：点击右上角的New repository新建仓库，输入仓库名称，然后创建仓库就可以了。</p>
</li>
<li><p>仓库创建好了之后，按右侧按钮复制SSH地址</p>
</li>
<li>一切准备就绪，接下来就是Git的事了，首先进入想要上传到GitHub的项目的文件夹下，创建好本地仓库，将想要上传的文件先添加到本地仓库中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;first commit&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>接下来将本地仓库与远程仓库取得关联,使用git remote add origin + 此次的SSH。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:onionwyc/confusion_matrix.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后在通过以下命令将代码push到GitHub。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来刷新GitHub就可以看到刚刚提交上去的代码了。</p>
</li>
</ul>
<h1 id="10-添加mathJax"><a href="#10-添加mathJax" class="headerlink" title="10.添加mathJax"></a>10.添加mathJax</h1><p>注意！！开始不知道为什么，传送的公式全都无法显示，后经本菜菜多方查证，原来hexo不支持公式。。。</p>
<p>原生hexo并不支持数学公式，需要安装插件 mathJax。<br>【1】 安装与配置mathJax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-math --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件 _config.yml 中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">math:</span><br><span class="line">  engine: &apos;mathjax&apos; # or &apos;katex&apos;</span><br><span class="line">  mathjax:</span><br><span class="line">    # src: custom_mathjax_source</span><br><span class="line">    config:</span><br><span class="line">      # MathJax config</span><br></pre></td></tr></table></figure></p>
<p>在 next 主题配置文件中 themes/next/_config.yml 中将 mathJax 设为 true:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure></p>
<p>【2】关于公式和矩阵的语法:</p>
<ul>
<li>（1）矩阵<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">  \begin&#123;bmatrix&#125;</span><br><span class="line">   cos(\theta) &amp; -sin(\theta)  \\\\      #注意，hexo写矩阵时只用两个斜杠，会出错，虽然mardown中是正确的。</span><br><span class="line">   sin(\theta) &amp; cos(\theta)</span><br><span class="line">  \end&#123;bmatrix&#125; \tag&#123;2&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>显示为：<br>$$<br>  \begin{bmatrix}<br>   cos(\theta) &amp; -sin(\theta)  \\<br>   sin(\theta) &amp; cos(\theta)<br>  \end{bmatrix} \tag{2}<br>$$</p>
<ul>
<li>（2）独占一行的公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$ A=a \bullet i+b \bullet j=[i,j] \bullet [a;b]=基\bullet坐标 \tag&#123;3&#125;$$</span><br><span class="line">#去掉\tag&#123; &#125;，则不显示标签</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>显示为：<br>$$ A=a \bullet i+b \bullet j=[i,j] \bullet [a;b]=基\bullet坐标 \tag{3}$$<br>注意，如何偷懒将乘号 $ \bullet$ (代码为 \bullet )写为 * ，整个公式将惨遭毁灭，我就是在这里卡住了很久，所以，规范符号用法，用什么查什么。</p>
<ul>
<li>（3） 行间的公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们都知道 $9 = 3 \times 3$</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>显示为：<br>我们都知道 $9 = 3 \times 3$</p>
<p>更多语法，我是参考的<a href="http://www.domuse.com/markdown-and-latex-equation-handbook.html" target="_blank" rel="noopener">流程图语法参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/24/Hexo+Github/" data-id="cjjxqbpr50001c4ujrilofhts" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/尝试折腾/">尝试折腾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-矩阵相关理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/13/矩阵相关理解/" class="article-date">
  <time datetime="2018-02-13T13:21:57.000Z" itemprop="datePublished">2018-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/13/矩阵相关理解/">矩阵相关理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>矩阵传达了两种信息：</p>
<p>（1）静态信息<br>一个矩阵其实同时包含两个信息 : </p>
<ul>
<li>在哪个向量空间下描述事物，即坐标系信息，以及坐标值信息。</li>
</ul>
<p>（2）动态信息<br>一个矩阵表示一种线性变换；</p>
<ul>
<li>矩阵的静态信息可以看作动态信息的矩阵经过变换后得来的。所以，一个矩阵可以拆分称几个矩阵相乘的形式。</li>
<li>一个 $m*n$ 的矩阵，即可看作一个线性映射：将所给矩阵从 $m$ 维空间映射到 $n$ 维空间。</li>
</ul>
<h1 id="1-线性变换"><a href="#1-线性变换" class="headerlink" title="1.线性变换"></a>1.线性变换</h1><p>【从动态信息角度理解】</p>
<p>【1】线性变换几何直观理解</p>
<p>例如 ：旋转、推移，伸缩：</p>
<ul>
<li>直线变换后仍是直线</li>
<li>直线比例保持不变</li>
<li>原点变换后仍是原点</li>
</ul>
<p>【2】矩阵变换</p>
<p>注意相乘的顺序：</p>
<p>$$A_{线性变换后}=W \bullet A=线性变换\bullet原矩阵\tag{1}$$</p>
<p>矩阵变换实际上是“基的变换”，见式（3）（4）。</p>
<p>举例子，一个以原点为中心的正方形，基向量为 $i,j$ :<br> $$<br>  \begin{bmatrix}<br>   1    \\<br>   0<br>  \end{bmatrix} \<br>$$<br>\begin{bmatrix}<br>   1    \\<br>   0<br>  \end{bmatrix} </p>
<p>然后逆时针旋转 $\theta$ ，即，旋转矩阵 $T_{rotate}=$<br>$$<br>  \begin{bmatrix}<br>   cos(\theta) &amp; -sin(\theta)  \\<br>   sin(\theta) &amp; cos(\theta)<br>  \end{bmatrix} \tag{2}<br>$$<br>则基向量变为 $i’,j‘$ ：<br>$$<br>  \begin{bmatrix}<br>   cos(\theta)    \\<br>   sin(\theta)<br>  \end{bmatrix} $$<br>  $$<br>\begin{bmatrix}<br>   -sin(\theta)   \\<br>   cos(\theta)<br>  \end{bmatrix}<br>  $$<br>也就是，旋转变换后的基向量就是旋转矩阵的列。————》列空间</p>
<p>用公式表述上述变化：<br>$$ A=a \bullet i+b \bullet j=[i,j] \bullet [a;b]=基\bullet坐标 \tag{3}$$</p>
<p>$$T_{rotate} \bullet A=T_{rotate} \bullet [i,j] \bullet [a;b]=[i’,j’] \bullet [a;b]=]A’ \tag{4}$$</p>
<p> $$A’=a \bullet i’+b \bullet j’\tag{5}$$</p>
<h1 id="2-行列式"><a href="#2-行列式" class="headerlink" title="2.行列式"></a>2.行列式</h1><p>[1] 【从动态信息角度理解】</p>
<p>行列式的本质：行列式是线性变换的伸缩因子</p>
<p>看上述的旋转，旋转矩阵 $T_{rotate}$的行列式的值为：<br> $$<br> \begin{matrix}<br>  cos(\theta) \bullet cos(\theta)-(sin(\theta) \bullet (-sin(\theta)))=1\<br>  \end{matrix} \tag{5}<br>  $$</p>
<p>即旋转变换后正方形的面积不变。</p>
<p>  $$| 行列式 | &gt; 1 , 对于图形有放大作用$$<br>$$| 行列式 |= 1 , 图形大小不变$$<br> $$0 &lt; | 行列式 | &lt; 1 , 对于图形有缩小作用 $$</p>
<p>[2] 【从静态信息角度理解/看成一个单纯的矩阵】</p>
<p>行列式值物理意义:</p>
<p> $$   二阶矩阵A的行列式值 = 矩阵A的列组成的平行四边形的面积$$<br>  $$三阶矩阵A的行列式值 = 矩阵A的列组成的平行六面体的体积$$</p>
<h1 id="3-秩"><a href="#3-秩" class="headerlink" title="3.秩:"></a>3.秩:</h1><p>（将一个矩阵看作线性变换来思考）</p>
<p>秩 ：列空间的维度</p>
<p> 数学家们定义，矩阵中的最大的不相关的向量的个数，就叫秩，即 列空间的维度。</p>
<ul>
<li><p>不在一条直线上的向量，即为不相关的向量。</p>
</li>
<li><p>【秩 = 列秩 = 行秩】 是恒成立的。所以直接把「列秩」称为「秩」也不算错误</p>
</li>
</ul>
<p>$$  图像A——&gt;秩为0的线性变换——&gt;一个零维的点$$<br>  $$图像A——&gt;秩为1的线性变换——&gt;一维直线$$<br>$$图像A——&gt;秩为2的线性变换——&gt;二维图像$$</p>
<p>所以,可以理解：</p>
<p> $没有线性变换矩阵可以将一个点还原为原来的图像，所以秩为0的矩阵没有逆矩阵，即 不可逆 。$</p>
<p>也就是：</p>
<p>$如果B经过线性变换P之后，得到结果M;但 M 无法经过线性变换还原为B,则称矩阵P不可逆$。</p>
<h1 id="4-低秩的意义"><a href="#4-低秩的意义" class="headerlink" title="4.低秩的意义"></a>4.低秩的意义</h1><p>形象地理解：</p>
<p>低秩表征一种冗余程度，秩越低表示数据冗余性越大，因为用很少几个基就可以表达所有数据了，也就是说，可以用 $rank(A)$ 个线性无关的特征向量通过线性组合，基本地还原图片$A$ 的信息。</p>
<p>一个矩阵是 low rank,说明它比它看起来更简单，矩阵信息量较低，实际坐标空间的维度就低，矩阵中大量内容线性相关，信息相关性高，则有规律，表示 $”可大幅压缩”$ ；</p>
<p>如果矩阵内容大量线性相关，则该矩阵可以等价位少数几个向量多次组合而来，对于机器学习而言，这种信息 $“易建模（我的通俗理解，容易学习出函数f）”$。</p>
<h1 id="5-矩阵的特征值理解"><a href="#5-矩阵的特征值理解" class="headerlink" title="5.矩阵的特征值理解"></a>5.矩阵的特征值理解</h1><p>此 <a href="https://www.bilibili.com/video/av6540378/" target="_blank" rel="noopener">视频</a> 非常形象，这个系列的都很好。看完就懂啦！</p>
<p>矩阵乘法对应了一个变换，是把任意一个向量变成另一个方向或长度都大多不同的新向量。</p>
<p>在这个变换的过程中，原向量主要发生旋转、伸缩的变化。</p>
<p>如果矩阵对某一个向量或某些向量只发生伸缩变换，不对这些向量产生旋转的效果，那么这些向量就</p>
<p>称为这个矩阵的特征向量，伸缩的比例就是特征值。</p>
<h1 id="6-奇异值的理解"><a href="#6-奇异值的理解" class="headerlink" title="6.奇异值的理解"></a>6.奇异值的理解</h1><p>【1】奇异值的物理意义</p>
<p>矩阵的奇异值是一个数学意义上的概念，一般由奇异值分解（即SVD分解，矩阵分解的一种）得到。</p>
<p>下面考虑二维矩阵 $A$（一张人脸图像，像素为 $450 \bullet 333$）。</p>
<p>将$A$进行奇异值分解，即分解为若干个秩一矩阵（秩为1的矩阵）之和：<br>$$<br> \begin{matrix}<br>  A=\sigma_1u_1v_1^T+ \sigma_2u_2v_2^T+…+\sigma_ru_rv_r^T   \<br>  \end{matrix} \tag{6}<br>  $$<br>其中等式右边每一项的系数 $\sigma$ 就是 奇异值 , $u$、$v$ 分别表示列向量，大小分别为 $450<em>1$ 和 $333</em>1$。注意，每一项 $uv^T$ 都是秩一矩阵。将奇异值大小顺序排列，假定式（6）是按奇异值大小顺序排列的。</p>
<ul>
<li><p>保留奇异值较大的几项（前几项），舍去奇异值较小的项（后几项），会得到和原图差别不大的图像。保留的项越多，结果和原图差距越小。对于含噪的，奇异值较小的项在很大概率上是噪点(在图像处理领域，应用于数据压缩和图像去噪)。</p>
</li>
<li><p>一般情况下，存储一张图片，并不需要存储所有的项，所以可以达到节省存储空间的目的。</p>
</li>
<li><p>假设保留前50项，结果已经很接近 $A$:$A$,$450 \bullet 333=149850$ ;<br>前50项,$(450+333+1) \bullet 50 = 39200$，存储量仅为前者的 20% 。</p>
</li>
<li><p>奇异值往往对应着矩阵中隐含的重要信息，且重要性和奇异值大小正相关。每个矩阵$A$都可以表示为一系列秩为 1 的“小矩阵”之和，而奇异值则衡量了这些“小矩阵”对于 $A$ 的权重。<br><a href="https://www.zhihu.com/question/22237507/answer/53804902" target="_blank" rel="noopener">知乎</a>郑宁的回答特别好。</p>
</li>
</ul>
<p>【2】奇异值的几何意义</p>
<p>   <a href="http://shartoo.github.io/SVD-decomponent/" target="_blank" rel="noopener">博客</a> 讲得特别好。<br>   未完待续 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/13/矩阵相关理解/" data-id="cjjxqbprf000gc4uj7rosos5u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ML数学基础/">ML数学基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-attention" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/15/attention/" class="article-date">
  <time datetime="2018-01-15T13:14:55.000Z" itemprop="datePublished">2018-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/15/attention/">attention</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h1><p>深度学习算法</p>
<hr>
<p> 参考文章  FEED-FORWARD NETWORKS WITH ATTENTION CAN SOLVE SOME LONG-TERM MEMORY PROBLEMS中的注意力机制</p>
<p><img src="http://img2016.itdadao.com/d/file/tech/2017/06/23/it3207822308481410.jpg" alt="我的头像"></p>
<p><img src="http://nathanlvzs.github.io/media/images/posts/2017/2017-11-17/high_attentionmodel-svg.png" alt="我的头像"><br>注意力模型，以n个参数 $ y_1,…,y_n$作为输入，以及上下文向量$ c $，返回一个向量$ z$，这个向量是聚焦于上下文信息的情况下对于$yi$的概要表示。更正式的，它返回的是$yi$的加权算术平均，权重是基于每个$yi$跟上下文向量$ c $的相关程度来确定的。<br>注意力模型的一个有趣特性是，算术平均的权重是可以获取得到并且绘制出来的，前面例子的图就是这么处理得到的，如果图像某一部分对应的权重越大，那这部分图像中的像素点会越白。</p>
<p>注意力模型这个黑箱子里的细节如下图所示。<br><img src="http://nathanlvzs.github.io/media/images/posts/2017/2017-11-17/detail_attentionmodel1.png" alt=""><br>这个网络看起来有些复杂，我们将会一步一步地解释。<br>模型的输入是下图中没有被模糊遮盖的部分，包括上下文向量$ c $和一系列的个$yi$。<br><img src="http://nathanlvzs.github.io/media/images/posts/2017/2017-11-17/detail_attentionmodel1.png" alt="我的头像"><br>接下来，模型使用一个tanh层计算得到$ m_1,…,m_n$。计算$ m_i$的输入包括上下文向量$ c $和对应的$yi$，也就是说每个$ m_i$的计算是相互独立的。<br><img src="http://nathanlvzs.github.io/media/images/posts/2017/2017-11-17/detail_attentionmodel_step12.png" alt=""><br>这里$ m_i$是向量。<br>接着，通过softmax计算得到每个权重。<br><img src="http://nathanlvzs.github.io/media/images/posts/2017/2017-11-17/detail_attentionmodel_step22.png" alt=""><br>$s_1$+…+$s_i$=1<br>这里，$ s_i$是$ m_i$的softmax结果在学习到的方向上的投影，是一个标量。<br>$ w_m$是所谓的学习到的方向，用以做内积<br>输出$ z$是所有$y_i$的算数加权平均，权重表示每个向量跟上下文向量的相关性。<br><img src="http://nathanlvzs.github.io/media/images/posts/2017/2017-11-17/detail_attentionmodel_step32.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/15/attention/" data-id="cjjxqbprd0009c4ujfkxnon5g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DeepLearning/">DeepLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Anaconda2-3共存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/13/Anaconda2-3共存/" class="article-date">
  <time datetime="2018-01-13T13:09:08.000Z" itemprop="datePublished">2018-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/13/Anaconda2-3共存/">Anaconda2+3共存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Anaconda-pycharm-中python-Anaconda2-3共存安装"><a href="#Anaconda-pycharm-中python-Anaconda2-3共存安装" class="headerlink" title="Anaconda/pycharm 中python/Anaconda2.3共存安装"></a>Anaconda/pycharm 中python/Anaconda2.3共存安装</h1><p> 环境配置</p>
<p>我是先装的Anaconda3（也可以先安装Anaconda2哒）<br>俺是基于windowsX64<br>对于配环境的菜鸟，网上教程太凌乱，有的还有错，我摸爬滚打后总结如下：</p>
<ul>
<li><p>[x] 在Anaconda3的基础上，安装Anaconda2.<br>正常看心情决定Anaconda2的路径；<br>如果失败，尝试Anaconda2的安装路径为：安装时浏览到Anaconda3/envs，然后在后边填写py2,就会将其安装到文件夹py2中。不用提前自己专门新建文件夹，否则会报错：路径存在。<br>安装中去掉第二个选择界面。即 Advanced installtion option 界面中两个选项的 勾选 即可。一路安装。直接在开始菜单就可以打开使用。<br>这样，你想用python3编写代码时，就打开python3的spyder；你想用python2编写代码时，就打开python2的spyder。两种环境的切换非常方便。</p>
</li>
<li><p>[x] 在Anaconda3的基础上，仅仅安装纯净的python2，也就是说没有其他包，需要的话还得重新下包。</p>
</li>
<li><p>全程在cmd中操作<br>在开始菜单栏中搜索cmd,并打开<br>1）先在conda中创建一个名为python2的环境，并下载对应版本python2.7<br>conda create –name python27 python=2.7<br>2）激活python2环境<br>activate  python27<br>3)在python2的环境下下载spyder和Jupter notebook<br>conda install spyder<br>因为我这里已经装过spyter了，如果第一次安装，系统会让你确定是否下载，输入 y 即可。<br>4) 下面我们可以看到菜单栏已经有了python2的spyter了。<br>5）下载Jupyter notebook，一样的方法。<br>conda install jupyter </p>
</li>
</ul>
<ul>
<li><p>spyder(python27)使用方法</p>
</li>
<li><p>打开cmd</p>
</li>
</ul>
<p>输入 activate python27<br>输入  spyder<br>成功打开后就是spyder(python27)</p>
<ul>
<li>spyder(python3.6)使用方法<br>依旧可以从菜单中打开</li>
</ul>
<p>接下来</p>
<p> 接下来，我们看如何在pycharm当中添加python2和python3，以便于pycharm 当中，我们可以随意切换python3，python2 环境：<br>pycharm–file–setting–搜索Project Interpreter–设置按钮–add local–寻找Anaconda3\envs\py2\python.exe<br>添加 - OK- Apply-  OK<br>到此结束,叽里呱啦弄完后，回头看觉得很简单~严肃欢快的学习吧~~~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/13/Anaconda2-3共存/" data-id="cjjxqbpr10000c4uj0fqlnnhu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他折腾/">其他折腾</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/git/" class="article-date">
  <time datetime="2018-01-11T13:05:26.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/git/">git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于版本控制-起步"><a href="#关于版本控制-起步" class="headerlink" title="关于版本控制-起步"></a>关于版本控制-起步</h1><p>其他折腾</p>
<hr>
<p>【1】 关于版本控制<br>       什么是版本控制？我为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本  修订情况的系统。在本书所展示的例子中，我们仅对保存着软件源代码的文本文件作版本控制管理，但实际上， 你可以对任何类型的文件进行版本控制。<br>采用版本控制系统（VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<p>【2】 代码版本管理系统的历史<br>   代码版本管理系统大致可以分为三个时代：<br>   第一代：本地式 –&gt; 第二代：客户端-服务器式  –&gt; 第三代：分布式</p>
<ul>
<li>本地式:许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单。不过坏处也不少：有时候会混淆所在的工作目录，一旦弄错文件丢了数据就没法撤销恢复。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异.   [简单粗暴地说  就是自己在自己的电脑上管自己的东西]</li>
<li>集中化的版本控制系统 (Centralized Version Control Systems，简称CVCS) 有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。 [只有中央服务器管理，一旦崩溃，完蛋。]</li>
<li><p>分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）<br>在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。见下图：</p>
<p>   <img src="https://git-scm.com/figures/18333fig0103-tn.png" alt="我的头像"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/11/git/" data-id="cjjxqbpr80004c4uj48rf65pk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-安装支持MXNet的Keras" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/10/安装支持MXNet的Keras/" class="article-date">
  <time datetime="2018-01-10T09:56:31.000Z" itemprop="datePublished">2018-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/10/安装支持MXNet的Keras/">安装支持MXNet的Keras</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前看到过<a href="https://zhuanlan.zhihu.com/p/27172280" target="_blank" rel="noopener">这篇文章</a>，介绍DMLC给keras增加了MXNet支持，但是当时的版本是keras1.2.2，现在最新的已经到了kera2，现在想使用最新的Keras和MXnet咋办，试了以下方法，亲测可行</p>
<p><strong>测试环境</strong><br>win10,Cuda9.0,cuDNNv7</p>
<p><strong>步骤</strong><br>首先删除本机现有的keras,一般默认在<code>c://user/xxx</code>文件下面<br>按照<a href="https://github.com/deep-learning-tools/keras/wiki/Installation-Guide---Keras-with-MXNet-backend" target="_blank" rel="noopener">这个教程</a></p>
<pre><code>mkdir keras
git clone https://github.com/deep-learning-tools/keras ./keras/
cd keras/
</code></pre><p>检查是否为<em>keras2_mxnet_backend</em></p>
<pre><code>git fetch
git checkout keras2_mxnet_backend
git pull
</code></pre><p>然后执行<code>setup.py</code> 安装keras</p>
<pre><code>python setup.py install
</code></pre><p>接下来安装最新的MXNet</p>
<pre><code>pip install mxnet-cu90
</code></pre><p>然后import一下 ，很奇怪我的还是tf的后端，进入<code>.keras</code>文件夹，把原来这样的json文件</p>
<pre><code>{
&quot;floatx&quot;: &quot;float32&quot;,
&quot;backend&quot;: &quot;tensorflow&quot;,
&quot;image_data_format&quot;: &quot;channels_last&quot;,
&quot;epsilon&quot;: 1e-07
}
</code></pre><p>改成</p>
<pre><code>{
&quot;floatx&quot;: &quot;float32&quot;,
&quot;backend&quot;: &quot;mxnet&quot;,
&quot;image_data_format&quot;: &quot;channels_first&quot;,
&quot;epsilon&quot;: 1e-07
}
</code></pre><p>就可以了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/10/安装支持MXNet的Keras/" data-id="cjjxqbpre000bc4ujs7jhtizy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/尝试折腾/">尝试折腾</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DeepLearning/">DeepLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ML数学基础/">ML数学基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他折腾/">其他折腾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/尝试折腾/">尝试折腾</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DeepLearning/" style="font-size: 20px;">DeepLearning</a> <a href="/tags/ML数学基础/" style="font-size: 20px;">ML数学基础</a> <a href="/tags/其他折腾/" style="font-size: 10px;">其他折腾</a> <a href="/tags/尝试折腾/" style="font-size: 20px;">尝试折腾</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/23/hello-world/">my onion</a>
          </li>
        
          <li>
            <a href="/2018/03/03/机器学习中的数学基础/">负梯度方向-函数值下降最快的方向</a>
          </li>
        
          <li>
            <a href="/2018/02/27/基本排序方法/">基本排序方法</a>
          </li>
        
          <li>
            <a href="/2018/02/25/CNN推导/">CNN推导+反向传播</a>
          </li>
        
          <li>
            <a href="/2018/02/24/Hexo+Github/">Hexo+Github+next+mathJax</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>